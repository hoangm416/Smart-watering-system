<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chi tiết thiết bị - Web tưới tiêu</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="style_device_detail.css">
</head>

<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="#">Web tưới tiêu - IoT và Ứng dụng</a>
            <a class="nav-link text-white" href="homepage.html">Trang chủ</a>
        </div>
    </nav>

    <!-- Main Content Container -->
    <div class="content">
        <!-- Điều chỉnh độ ẩm -->
        <div class="data-container">
            <h3 class="text-center mb-4">
                <p id="status"></p>
            </h3>
        </div>

        <!-- Đồ thị theo dõi độ ẩm -->
        <div class="data-container">
            <h3 class="text-center mb-4">Đồ thị độ ẩm thời gian thực</h3>
            <!-- Biểu đồ -->
            <canvas id="realtime-humidity-chart" width="800" height="400"></canvas>
        </div>

        <!-- Lịch sử tưới cây -->
        <div class="data-container">
            <h3 class="text-center mb-4">Lịch sử độ ẩm</h3>
            <!-- Khung chọn ngày -->
            <div class="date-picker-container" style="text-align: center; margin-bottom: 20px;">
                <label for="date-picker">Chọn ngày:</label>
                <input type="date" id="date-picker" />
            </div>
            <!-- Biểu đồ -->
            <canvas id="humidity-chart" width="400" height="200"></canvas>
        </div>
    </div>

    <!-- Thêm thư viện regression.js và TensorFlow.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/regression/2.0.1/regression.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-analytics.js";
        import { getDatabase, ref, onValue, set, query, limitToLast } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDm9JTh2asPyvghYfTThNuYe2vESgvRTfw",
            authDomain: "iot-watering-caf9b.firebaseapp.com",
            databaseURL: "https://iot-watering-caf9b-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "iot-watering-caf9b",
            storageBucket: "iot-watering-caf9b.firebasestorage.app",
            messagingSenderId: "255169422238",
            appId: "1:255169422238:web:5368795df5ee2c3009ec8f",
            measurementId: "G-TQYZKNEL5B"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const database = getDatabase(app);

        // Lấy deviceId từ URL
        const urlParams = new URLSearchParams(window.location.search);
        const deviceId = urlParams.get('device');

        if (!deviceId) {
            alert("Thiếu thông tin thiết bị! Vui lòng cung cấp deviceId trong URL.");
            throw new Error("Thiếu deviceId");
        }

        const devicePath = `Plant_Watering/Devices/${deviceId}`;
        const setHumidityRef = ref(database, `${devicePath}/setHumidity`);
        const statusRef = ref(database, `${devicePath}/Status`);
        const historyRef = ref(database, `${devicePath}/history`);
        const historyPrevious = ref(database, `${devicePath}/history_previous_day`);

        // Theo dõi trạng thái của thiết bị
        onValue(statusRef, (snapshot) => {
            const status = snapshot.val();
            const statusElement = document.getElementById('status');
            const messageRef = ref(database, `${devicePath}/message`);

            // Lấy thông báo message từ Firebase
            onValue(messageRef, (messageSnapshot) => {
                const message = messageSnapshot.val();

                if (status) {
                    statusElement.innerHTML = `Trạng thái máy bơm: Bật<br>${message}`;
                    statusElement.className = "status-on";
                } else {
                    statusElement.innerHTML = `Trạng thái máy bơm: Tắt<br>${message}`;
                    statusElement.className = "status-off";
                }
            });
        });


        // Khởi tạo biểu đồ
        let chart = null;
        const ctx = document.getElementById('realtime-humidity-chart').getContext('2d');
        const WINDOW_SIZE = 3; // Kích thước cửa sổ 
        
        const ctx2 = document.getElementById('humidity-chart').getContext('2d');
        let humidityChart;

        function createChart(labels, data) {
            if (humidityChart) {
                humidityChart.destroy();
            }
            humidityChart = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Độ ẩm (%)',
                        data: data,
                        borderColor: 'green',
                        fill: false,
                        tension: 0.1,
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Thời gian',
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Độ ẩm (%)',
                            },
                            suggestedMin: 0,
                            suggestedMax: 100,
                        }
                    }
                }
            });
        }

        function updateChartForDate(selectedDate) {
            onValue(historyRef, (snapshot) => {
                const historyData = snapshot.val();
                const labels = [];
                const data = [];

                for (const key in historyData) {
                    if (historyData.hasOwnProperty(key)) {
                        const recordDate = new Date(historyData[key].timestamp);
                        const recordDateString = recordDate.toISOString().split('T')[0];

                        if (selectedDate === '2024-12-28' && recordDateString <= '2024-12-28') {
                            labels.push(historyData[key].timestamp);
                            data.push(historyData[key].humidity);
                        } else if (recordDateString === selectedDate) {
                            labels.push(historyData[key].timestamp);
                            data.push(historyData[key].humidity);
                        }
                    }
                }

                createChart(labels, data);
            });
        }

        document.getElementById('date-picker').addEventListener('change', (event) => {
            const selectedDate = event.target.value;
            updateChartForDate(selectedDate);
        });

        // Initialize chart with default date
        updateChartForDate('2024-12-28');

        // Realtime update
        onValue(historyRef, (snapshot) => {
            const historyData = snapshot.val();
            const labels = [];
            const data = [];

            for (const key in historyData) {
                if (historyData.hasOwnProperty(key)) {
                    labels.push(historyData[key].timestamp);
                    data.push(historyData[key].humidity);
                }
            }

            createChart(labels, data);
        });
        
        function initializeChart() {
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [], // Thời gian sẽ được thêm sau
                    datasets: [
                        {
                            label: 'Độ ẩm thực tế (%)',
                            data: [], // Dữ liệu độ ẩm sẽ được thêm sau
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(75, 192, 192, 1)'
                        },
                        {
                            label: 'Dự đoán độ ẩm bằng Hồi quy Đa thức (%)',
                            data: [], // Dữ liệu dự đoán sẽ được thêm sau
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderDash: [10, 5],
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0
                        },
                        {
                            label: 'Đường Hồi Quy Đa Thức',
                            data: [], // Dữ liệu hồi quy sẽ được thêm sau
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0,
                            borderDash: [5, 5]
                        },
                        {
                            label: 'Dự đoán độ ẩm bằng LSTM (%)',
                            data: [], // Dữ liệu dự đoán LSTM sẽ được thêm sau
                            borderColor: 'rgba(255, 206, 86, 1)',
                            borderDash: [10, 5],
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0
                        },
                        {
                            label: 'Đường Hồi Quy LSTM',
                            data: [], // Dữ liệu hồi quy LSTM sẽ được thêm sau
                            borderColor: 'rgba(153, 102, 255, 1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 0,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    animation: {
                        duration: 0 // Loại bỏ hiệu ứng để cập nhật nhanh
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Thời gian'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Độ ẩm (%)'
                            },
                            beginAtZero: true,
                            suggestedMax: 100
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Hàm tính hồi quy đa thức
        function polynomialRegression(data, degree) {
            // Tạo dữ liệu đầu vào cho regression.js
            const dataForRegression = data.map((y, x) => [x, y]);

            // Thực hiện hồi quy đa thức với độ bậc đã chọn
            const result = regression.polynomial(dataForRegression, { order: degree });

            return result;
        }

        // Hàm tính hàm mất mát (Mean Squared Error)
        function calculateMSE(predictions, actuals) {
            let mse = 0;
            for (let i = 0; i < actuals.length; i++) {
                mse += Math.pow(predictions[i] - actuals[i], 2);
            }
            return mse / actuals.length;
        }

        // Hàm tìm độ bậc tối ưu từ 1 đến 15
        function findOptimalDegree(data, minDegree = 1, maxDegree = 15) {
            let optimalDegree = minDegree;
            let minMSE = Infinity;

            for (let degree = minDegree; degree <= maxDegree; degree++) {
                const regressionResult = polynomialRegression(data, degree);
                const { equation } = regressionResult;

                // Tính giá trị hồi quy tại mỗi điểm dữ liệu
                const predictions = data.map((_, x) => {
                    let y = 0;
                    equation.forEach((coef, index) => {
                        y += coef * Math.pow(x, index);
                    });
                    return y;
                });

                const mse = calculateMSE(predictions, data);

                console.log(`Degree: ${degree}, MSE: ${mse}`);

                if (mse < minMSE) {
                    minMSE = mse;
                    optimalDegree = degree;
                }
            }

            return optimalDegree;
        }

        // Hàm dự đoán độ ẩm tiếp theo bằng hồi quy đa thức
        function predictNextValues(data, numPredictions, degree) {
            const regressionResult = polynomialRegression(data, degree);
            const { equation } = regressionResult;
            const lastIndex = data.length;

            const predictions = [];

            for (let i = 1; i <= numPredictions; i++) {
                const x = lastIndex + i;
                // Tính giá trị dự đoán bằng cách thay x vào phương trình đa thức
                let predictedValue = 0;
                equation.forEach((coef, index) => {
                    predictedValue += coef * Math.pow(x, index);
                });
                // Làm tròn và giới hạn trong khoảng 0-100%
                predictedValue = Math.max(0, Math.min(100, parseFloat(predictedValue.toFixed(2))));
                predictions.push(predictedValue);
            }

            return predictions;
        }

        // Hàm tính giá trị hồi quy đa thức tại mỗi điểm dữ liệu hiện có
        function calculateRegressionCurve(data, degree) {
            const regressionResult = polynomialRegression(data, degree);
            const { equation } = regressionResult;

            const regressionData = data.map((_, x) => {
                let y = 0;
                equation.forEach((coef, index) => {
                    y += coef * Math.pow(x, index);
                });
                // Làm tròn và giới hạn trong khoảng 0-100%
                y = Math.max(0, Math.min(100, parseFloat(y.toFixed(2))));
                return y;
            });

            return regressionData;
        }

        // Hàm chuẩn bị dữ liệu cho LSTM
        function prepareLSTMData(data, windowSize = WINDOW_SIZE) {
            const inputs = [];
            const labels = [];

            for (let i = 0; i < data.length - windowSize; i++) {
                // Chuyển đổi mỗi giá trị độ ẩm thành một mảng con đơn lẻ
                const input = data.slice(i, i + windowSize).map(value => [value]);
                const label = data[i + windowSize];
                inputs.push(input);
                labels.push(label);
            }

            return { inputs, labels };
        }

        // Hàm dự đoán với LSTM sử dụng TensorFlow.js
        async function predictWithLSTM(data, numPredictions, windowSize = WINDOW_SIZE) {
            if (data.length < windowSize) {
                console.warn("Không đủ dữ liệu để huấn luyện LSTM.");
                return Array(numPredictions).fill(null);
            }

            // Chuẩn bị dữ liệu
            const { inputs, labels } = prepareLSTMData(data, windowSize);

            // Chuyển đổi dữ liệu thành tensor 3D
            const xs = tf.tensor3d(inputs, [inputs.length, windowSize, 1]);
            const ys = tf.tensor2d(labels, [labels.length, 1]);

            // Định nghĩa mô hình LSTM
            const model = tf.sequential();
            model.add(tf.layers.lstm({ units: 50, activation: 'tanh', inputShape: [windowSize, 1] }));
            model.add(tf.layers.dense({ units: 1 }));

            // Biên dịch mô hình
            model.compile({
                optimizer: tf.train.adam(),
                loss: 'meanSquaredError'
            });

            // Huấn luyện mô hình
            await model.fit(xs, ys, {
                epochs: 100,
                shuffle: false,
                verbose: 0
            });

            // Sử dụng dữ liệu cuối cùng để dự đoán
            let lastWindow = data.slice(data.length - windowSize).map(value => [value]);
            const predictions = [];

            for (let i = 0; i < numPredictions; i++) {
                const input = tf.tensor3d([lastWindow], [1, windowSize, 1]);
                const pred = model.predict(input);
                const predValue = (await pred.data())[0];
                const clampedPred = Math.max(0, Math.min(100, parseFloat(predValue.toFixed(2))));
                predictions.push(clampedPred);
                lastWindow = [...lastWindow.slice(1), [clampedPred]];
            }

            return predictions;
        }

        // Hàm tính giá trị hồi quy LSTM tại mỗi điểm dữ liệu hiện có
        async function calculateLSTMRegression(data, windowSize = WINDOW_SIZE) {
            if (data.length < windowSize) {
                console.warn("Không đủ dữ liệu để tính hồi quy LSTM.");
                return Array(data.length).fill(null);
            }

            // Chuẩn bị dữ liệu
            const { inputs, labels } = prepareLSTMData(data, windowSize);

            // Chuyển đổi dữ liệu thành tensor 3D
            const xs = tf.tensor3d(inputs, [inputs.length, windowSize, 1]);
            const ys = tf.tensor2d(labels, [labels.length, 1]);

            // Định nghĩa mô hình LSTM thực sự
            const model = tf.sequential();
            model.add(tf.layers.lstm({ units: 50, activation: 'tanh', inputShape: [windowSize, 1] }));
            model.add(tf.layers.dense({ units: 1 }));

            // Biên dịch mô hình
            model.compile({
                optimizer: tf.train.adam(),
                loss: 'meanSquaredError'
            });

            // Huấn luyện mô hình
            await model.fit(xs, ys, {
                epochs: 100,
                shuffle: false,
                verbose: 0
            });

            // Dự đoán cho từng điểm dữ liệu hiện có để tạo đường hồi quy
            const regressionCurve = [];

            for (let i = 0; i < data.length; i++) {
                if (i < windowSize) {
                    regressionCurve.push(null); // Không đủ dữ liệu để dự đoán
                    continue;
                }
                const window = data.slice(i - windowSize, i).map(value => [value]);
                const input = tf.tensor3d([window], [1, windowSize, 1]);
                const pred = model.predict(input);
                const predValue = (await pred.data())[0];
                const clampedPred = Math.max(0, Math.min(100, parseFloat(predValue.toFixed(2))));
                regressionCurve.push(clampedPred);
            }

            return regressionCurve;
        }

        // Hàm cập nhật dữ liệu của biểu đồ
        async function updateChart(historyData) {
            const labels = [];
            const dataPoints = [];

            // Sắp xếp dữ liệu theo timestamp nếu cần
            const sortedEntries = Object.entries(historyData).sort((a, b) => {
                return new Date(a[1].timestamp) - new Date(b[1].timestamp);
            });

            sortedEntries.forEach(([key, entry], index) => {
                labels.push(entry.timestamp); // Thời gian
                dataPoints.push(entry.humidity); // Độ ẩm
            });

            // Cập nhật dữ liệu thực tế
            chart.data.labels = labels;
            chart.data.datasets[0].data = dataPoints;

            // Tìm độ bậc tối ưu cho hồi quy đa thức
            const degree = findOptimalDegree(dataPoints, 1, 15);
            console.log(`Độ bậc tối ưu cho hồi quy đa thức: ${degree}`);

            // Tính toán hồi quy đa thức và đường hồi quy
            const regressionCurve = calculateRegressionCurve(dataPoints, degree);
            chart.data.datasets[2].data = regressionCurve;

            // Tính toán dự đoán sử dụng hồi quy đa thức bậc tối ưu
            const numPredictions = 5;
            const predictionsPoly = predictNextValues(dataPoints, numPredictions, degree);
            const lastTimestamp = new Date(sortedEntries[sortedEntries.length - 1][1].timestamp);

            // Giả định rằng các điểm tiếp theo cách đều nhau theo khoảng thời gian giữa các điểm hiện tại
            const timeIncrement = 60000; // Ví dụ: mỗi điểm cách nhau 1 phút (60000 ms)
            const predictedLabels = [];

            for (let i = 1; i <= numPredictions; i++) {
                const predictedTime = new Date(lastTimestamp.getTime() + i * timeIncrement);
                // Định dạng thời gian theo mong muốn, ví dụ: 'HH:MM'
                const formattedTime = `${predictedTime.getHours().toString().padStart(2, '0')}:${predictedTime.getMinutes().toString().padStart(2, '0')}`;
                predictedLabels.push(formattedTime);
            }

            // Cập nhật dữ liệu dự đoán đa thức
            const extendedLabels = labels.concat(predictedLabels);
            chart.data.labels = extendedLabels;

            // Tạo một mảng chứa NaN cho các điểm dữ liệu thực tế và thêm các dự đoán vào cuối
            const actualDataWithNaN = [...dataPoints, ...Array(numPredictions).fill(null)];
            chart.data.datasets[0].data = actualDataWithNaN;

            // Cập nhật đường hồi quy đa thức với dữ liệu thực tế
            chart.data.datasets[2].data = regressionCurve;

            // Tạo một mảng chứa các dự đoán đa thức với các giá trị NaN cho dữ liệu không có
            const predictedDataWithNaN = Array(dataPoints.length).fill(null).concat(predictionsPoly);
            chart.data.datasets[1].data = predictedDataWithNaN;

            // Tính toán và cập nhật đường hồi quy LSTM
            const regressionCurveLSTM = await calculateLSTMRegression(dataPoints);
            chart.data.datasets[4].data = regressionCurveLSTM;

            // Dự đoán tương lai bằng LSTM
            const predictionsLSTM = await predictWithLSTM(dataPoints, numPredictions);
            console.log(`Dự đoán LSTM: ${predictionsLSTM}`);

            // Cập nhật dữ liệu dự đoán LSTM
            chart.data.datasets[3].data = Array(dataPoints.length).fill(null).concat(predictionsLSTM);

            chart.update(); // Cập nhật biểu đồ mà không phá hủy
        }

        // Lắng nghe thay đổi dữ liệu Firebase theo thời gian thực
        const recentQuery = query(historyRef, limitToLast(20)); // Tăng số lượng dữ liệu nếu cần
        onValue(recentQuery, (snapshot) => {
            if (snapshot.exists()) {
                const historyData = snapshot.val();
                console.log("Lịch sử độ ẩm cập nhật:", historyData);
                updateChart(historyData);
            } else {
                console.log("Không có dữ liệu lịch sử độ ẩm.");
            }
        }, (error) => {
            console.error("Lỗi khi lấy dữ liệu history:", error);
        });

        // Khởi tạo biểu đồ
        initializeChart();

        // Hàm cập nhật nhãn cho thanh trượt độ ẩm
        function updateMoistureLabel(value) {
            document.getElementById('moisture-value').innerText = value;
        }

    </script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
</body>

</html>
